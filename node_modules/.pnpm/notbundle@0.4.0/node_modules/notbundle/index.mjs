import fs from "node:fs";
import path from "node:path";
import fastGlob from "fast-glob";
import os from "node:os";
import { watch as watch$1 } from "chokidar";
function resolvePlugins(config) {
  return [
    swc(),
    ...config.plugins ?? []
  ];
}
function swc() {
  let swc2;
  let config;
  return {
    name: ":swc",
    async configResolved(_config) {
      var _a, _b;
      config = _config;
      const transformOptions = _config.transformOptions;
      transformOptions.env ?? (transformOptions.env = {});
      (_a = transformOptions.env).targets ?? (_a.targets = {});
      (_b = transformOptions.env.targets).node ?? (_b.node = "14");
      transformOptions.module ?? (transformOptions.module = { type: "commonjs" });
    },
    async transform({ filename, code }) {
      var _a, _b;
      swc2 ?? (swc2 = await import("@swc/core"));
      const lang = path.extname(filename).slice(1);
      const { transformOptions } = config;
      transformOptions.jsc ?? (transformOptions.jsc = {});
      if (["ts", "tsx"].includes(lang)) {
        (_a = transformOptions.jsc).parser ?? (_a.parser = { syntax: "typescript", tsx: lang === "tsx" });
      } else {
        (_b = transformOptions.jsc).parser ?? (_b.parser = { syntax: "ecmascript", jsx: lang === "jsx" });
      }
      return swc2.transformSync(code, {
        filename,
        ...transformOptions
      });
    }
  };
}
const colours = {
  $_$: (c) => (str) => `\x1B[${c}m` + str + "\x1B[0m",
  gary: (str) => colours.$_$(90)(str),
  cyan: (str) => colours.$_$(36)(str),
  yellow: (str) => colours.$_$(33)(str),
  green: (str) => colours.$_$(32)(str),
  red: (str) => colours.$_$(31)(str)
};
const JS_EXTENSIONS = [".ts", ".tsx", ".js", ".jsx"];
const STATIC_JS_EXTENSIONS = [".json", ".node", ".wasm"];
function ensureDir(filename) {
  const dir = path.dirname(filename);
  !fs.existsSync(dir) && fs.mkdirSync(dir, { recursive: true });
  return filename;
}
function jsType(filename) {
  return {
    js: !filename.endsWith(".d.ts") && JS_EXTENSIONS.some((ext) => filename.endsWith(ext)),
    static: STATIC_JS_EXTENSIONS.some((ext) => filename.endsWith(ext))
  };
}
const isWindows = os.platform() === "win32";
function slash(p) {
  return p.replace(/\\/g, "/");
}
function normalizePath(id) {
  return path.posix.normalize(isWindows ? slash(id) : id);
}
async function resolveConfig(config) {
  var _a, _b, _c, _d, _e, _f;
  const {
    root,
    include,
    output,
    logger = {},
    transformOptions = {}
  } = config;
  const resolvedRoot = normalizePath(
    root ? path.resolve(root) : process.cwd()
  );
  const resolved = {
    root: resolvedRoot,
    include: include.map((p) => normalizePath(p).replace(resolvedRoot + "/", "")),
    output: output ? normalizePath(path.isAbsolute(output) ? output : path.join(resolvedRoot, output)) : output,
    plugins: resolvePlugins(config),
    logger,
    transformOptions,
    config,
    extensions: JS_EXTENSIONS,
    experimental: {
      include2files,
      include2globs,
      input2output
    }
  };
  (_a = resolved.logger).error ?? (_a.error = (...msg) => loggerFn("error", ...msg));
  (_b = resolved.logger).info ?? (_b.info = (...msg) => loggerFn("info", ...msg));
  (_c = resolved.logger).success ?? (_c.success = (...msg) => loggerFn("success", ...msg));
  (_d = resolved.logger).warn ?? (_d.warn = (...msg) => loggerFn("warn", ...msg));
  (_e = resolved.logger).log ?? (_e.log = (...msg) => loggerFn("log", ...msg));
  for (const plugin of resolved.plugins) {
    await ((_f = plugin.configResolved) == null ? void 0 : _f.call(plugin, resolved));
  }
  return resolved;
}
function include2files(config, include = config.include) {
  return fastGlob.sync(include2globs(config, include), { cwd: config.root }).filter((p) => config.extensions.includes(path.extname(p)));
}
function include2globs(config, files = config.include) {
  return files.map((file) => path.posix.join(config.root, file)).map((file) => {
    if (fs.existsSync(file)) {
      return fs.statSync(file).isDirectory() ? path.posix.join(file, "**/*") : file;
    }
    for (const ext of config.extensions) {
      let filename = file + ext;
      if (fs.existsSync(filename)) {
        return filename;
      }
    }
  }).filter((file) => file != null);
}
function input2output(config, filename) {
  const { root, output } = config;
  if (!output)
    return;
  const file = normalizePath(filename).replace(root + "/", "");
  const destname = path.posix.join(
    output,
    config.include.length === 1 ? file.slice(file.indexOf("/") + 1) : file
  );
  const extname = path.extname(destname);
  return config.extensions.includes(extname) ? destname.replace(extname, ".js") : destname;
}
function loggerFn(type, ...message) {
  if (type !== "log") {
    const dict = {
      error: "red",
      info: "cyan",
      success: "green",
      warn: "yellow"
    };
    const color = dict[type];
    message = message.map((msg) => colours[color](msg));
  }
  console.log(...message);
}
async function build(config) {
  const resolved = await resolveConfig(config);
  return Promise.all(
    resolved.experimental.include2files(resolved).map((filename) => buildFile(resolved, filename))
  );
}
async function buildFile(config, filename) {
  var _a, _b;
  const {
    root,
    plugins,
    experimental,
    logger
  } = config;
  let code = fs.readFileSync(filename, "utf8");
  let map;
  const destname = experimental.input2output(config, filename);
  const buildResult = { filename, destname };
  let done = false;
  for (const plugin of plugins) {
    if (done)
      break;
    const result = await ((_a = plugin.transform) == null ? void 0 : _a.call(plugin, {
      filename,
      code,
      done() {
        done = true;
      }
    }));
    if (!result)
      continue;
    if (typeof result === "string") {
      code = result;
    } else if (Object.prototype.toString.call(result) === "[object Object]") {
      code = result.code;
      if (result.map != null) {
        map = result.map;
      }
    }
  }
  if (destname) {
    if (destname === filename) {
      const message = `Input and output are the same file
  ${filename} -> ${destname}`;
      throw new Error(message);
    }
    ensureDir(destname);
    if (map) {
      let mappings;
      try {
        mappings = JSON.parse(map);
      } catch (error) {
        logger.warn("[sourcemap]:\n", error);
      }
      if (mappings) {
        const parsed = path.parse(destname);
        mappings.file = parsed.base;
        mappings.sources = [path.relative(parsed.dir, filename)];
        fs.writeFileSync(destname + ".map", JSON.stringify(mappings));
        code += `
//# sourceMappingURL=${path.basename(destname)}.map`;
      }
    }
    fs.writeFileSync(destname, code);
    logger.info("[write]", new Date().toLocaleTimeString(), `${path.relative(root, destname)}`);
  }
  buildResult.code = code;
  buildResult.map = map;
  for (const plugin of plugins) {
    await ((_b = plugin.ondone) == null ? void 0 : _b.call(plugin, buildResult));
  }
  return buildResult;
}
async function watch(config) {
  if (!config.watch)
    config.watch = {};
  const resolved = await resolveConfig(config);
  const { experimental, plugins } = resolved;
  const watcher = watch$1(experimental.include2globs(resolved), config.watch);
  watcher == null ? void 0 : watcher.on("all", (event, _filepath) => {
    var _a;
    const filepath = normalizePath(_filepath);
    const destpath = experimental.input2output(resolved, filepath);
    for (const plugin of plugins) {
      (_a = plugin.onwatch) == null ? void 0 : _a.call(plugin, event, filepath);
    }
    switch (event) {
      case "add":
      case "change": {
        jsType(filepath).js && buildFile(resolved, filepath);
        break;
      }
      case "addDir":
        break;
      case "unlink":
        destpath && fs.existsSync(destpath) && fs.unlinkSync(destpath);
        break;
      case "unlinkDir":
        destpath && fs.existsSync(destpath) && fs.rmSync(destpath, { recursive: true, force: true });
        break;
    }
  });
  return watcher;
}
export {
  build,
  colours,
  normalizePath,
  resolveConfig,
  watch
};
