"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const vite = require("vite");
const index = require("./index.js");
require("node:module");
async function electronSimple(options) {
  const opts = [options.main];
  if (options.preload) {
    const {
      input,
      vite: viteConfig = {},
      ...preloadOptions
    } = options.preload;
    const preload = {
      onstart(args) {
        args.reload();
      },
      ...preloadOptions,
      vite: vite.mergeConfig({
        build: {
          rollupOptions: {
            input,
            output: {
              // For use the Electron API - `import { contextBridge, ipcRenderer } from 'electron'`,
              // Note, however, that `preload.ts` should not be split. ðŸš§
              format: "cjs",
              // Whether Node.js is enabled in the Main process or not, the Preload scripts supports loading `electron` module, 
              // so we need to build it in `cjs` format.
              // e.g.
              // import { ipcRenderer } from 'electron'
              // // â†“â†“â†“â†“ Build with `cjs` format â†“â†“â†“â†“
              // const { ipcRenderer } = require('electron')
              // When Rollup builds code in `cjs` format, it will automatically split the code into multiple chunks, and use `require()` to load them, 
              // and use `require()` to load other modules when `nodeIntegration: false` in the Main process Errors will occur.
              // So we need to configure Rollup not to split the code when building to ensure that it works correctly with `nodeIntegration: false`.
              inlineDynamicImports: true,
              // https://github.com/vitejs/vite/blob/v4.4.9/packages/vite/src/node/build.ts#L604
              entryFileNames: "[name].js",
              chunkFileNames: "[name].js",
              assetFileNames: "[name].[ext]"
            }
          }
        }
      }, viteConfig)
    };
    opts.push(preload);
  }
  const plugins = index.default(opts);
  if (options.renderer) {
    try {
      const renderer = await import("vite-plugin-electron-renderer");
      plugins.push(renderer.default(options.renderer));
    } catch (error) {
      if (error.code === "ERR_MODULE_NOT_FOUND") {
        throw new Error(
          `\`renderer\` option dependency "vite-plugin-electron-renderer" not found. Did you install it? Try \`npm i -D vite-plugin-electron-renderer\`.`
        );
      }
      throw error;
    }
  }
  return plugins;
}
exports.default = electronSimple;
