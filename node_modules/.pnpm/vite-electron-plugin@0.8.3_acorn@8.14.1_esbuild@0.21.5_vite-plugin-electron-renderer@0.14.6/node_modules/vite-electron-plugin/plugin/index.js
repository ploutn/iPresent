"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("node:path");
const os = require("node:os");
const fs = require("node:fs");
const node_module = require("node:module");
const esbuild = require("esbuild");
class MagicString {
  constructor(str) {
    this.str = str;
    this.starts = "";
    this.ends = "";
  }
  append(content) {
    this.ends += content;
    return this;
  }
  prepend(content) {
    this.starts = content + this.starts;
    return this;
  }
  overwrite(start, end, content) {
    if (end < start) {
      throw new Error(`"end" con't be less than "start".`);
    }
    if (!this.overwrites) {
      this.overwrites = [];
    }
    this.overwrites.push({ loc: [start, end], content });
    return this;
  }
  toString() {
    let str = this.str;
    if (this.overwrites) {
      const arr = [...this.overwrites].sort((a, b) => b.loc[0] - a.loc[0]);
      for (const { loc: [start, end], content } of arr) {
        str = str.slice(0, start) + content + str.slice(end);
      }
    }
    return this.starts + str + this.ends;
  }
}
function relativeify(relative) {
  if (relative === "") {
    return ".";
  }
  if (!relative.startsWith(".")) {
    return "./" + relative;
  }
  return relative;
}
async function walk(ast, visitors, ancestors = []) {
  var _a;
  if (!ast)
    return;
  if (Array.isArray(ast)) {
    for (const element of ast) {
      await walk(element, visitors, ancestors);
    }
  } else {
    ancestors = ancestors.concat(ast);
    for (const key of Object.keys(ast)) {
      await (typeof ast[key] === "object" && walk(ast[key], visitors, ancestors));
    }
  }
  await ((_a = visitors[ast.type]) === null || _a === void 0 ? void 0 : _a.call(visitors, ast, ancestors));
}
walk.sync = function walkSync(ast, visitors, ancestors = []) {
  var _a;
  if (!ast)
    return;
  if (Array.isArray(ast)) {
    for (const element of ast) {
      walkSync(element, visitors, ancestors);
    }
  } else {
    ancestors = ancestors.concat(ast);
    for (const key of Object.keys(ast)) {
      typeof ast[key] === "object" && walkSync(ast[key], visitors, ancestors);
    }
  }
  (_a = visitors[ast.type]) === null || _a === void 0 ? void 0 : _a.call(visitors, ast, ancestors);
};
const isWindows = os.platform() === "win32";
function slash(p) {
  return p.replace(/\\/g, "/");
}
function normalizePath(id) {
  return path.posix.normalize(isWindows ? slash(id) : id);
}
const COLOURS = {
  $: (c) => (str) => `\x1B[${c}m` + str + "\x1B[0m",
  gary: (str) => COLOURS.$(90)(str),
  cyan: (str) => COLOURS.$(36)(str),
  yellow: (str) => COLOURS.$(33)(str),
  green: (str) => COLOURS.$(32)(str),
  red: (str) => COLOURS.$(31)(str)
};
function alias(aliases, options) {
  let acorn;
  return {
    name: "plugin-alias",
    async transform({ code, filename: importer }) {
      if (!/require|import/.test(code))
        return;
      try {
        acorn ?? (acorn = await import("acorn"));
      } catch {
        throw new Error('[plugin/alias] dependency "acorn". Did you install it?');
      }
      const ast = acorn.parse(
        code,
        Object.assign({
          ecmaVersion: 2020
        }, options == null ? void 0 : options.acornOptions)
      );
      const ms = new MagicString(code);
      const nodes = [];
      walk.sync(ast, {
        CallExpression(node) {
          if (node.callee.name !== "require")
            return;
          const { start, end, arguments: args } = node;
          if (args.length === 1 && args[0].type === "Literal") {
            const literal = args[0];
            nodes.push({
              type: "require",
              start,
              end,
              importee: {
                start: literal.start,
                end: literal.end,
                raw: literal.raw
              }
            });
          }
        },
        ImportExpression(node) {
          const { start, end, source } = node;
          nodes.push({
            type: "import",
            start,
            end,
            importee: {
              start: source.start,
              end: source.end,
              raw: source.raw
            }
          });
        }
      });
      for (const node of nodes) {
        const {
          start,
          end,
          importee,
          type
        } = node;
        const source = importee.raw.slice(1, -1);
        const option = aliases.find((opt) => opt.find instanceof RegExp ? opt.find.test(source) : source.startsWith(opt.find + "/"));
        if (!option)
          continue;
        let { find, replacement } = option;
        if (path.isAbsolute(replacement)) {
          replacement = path.relative(path.dirname(importer), replacement);
        }
        replacement = relativeify(normalizePath(replacement));
        replacement = 'require("' + source.replace(find, replacement) + '")';
        if (type === "import") {
          replacement = `new Promise((resolve, reject) => {try {resolve(${replacement})} catch (error) {reject(error)}})`;
        }
        ms.overwrite(start, end, replacement);
      }
      return ms.toString();
    }
  };
}
function ensureDir(filename) {
  const dir = path.dirname(filename);
  !fs.existsSync(dir) && fs.mkdirSync(dir, { recursive: true });
  return filename;
}
function node_modules(root, count = 0) {
  if (node_modules.p) {
    return node_modules.p;
  }
  const p = path.join(root, "node_modules");
  if (fs.existsSync(p)) {
    return node_modules.p = p;
  }
  if (count >= 19) {
    throw new Error("Can not found node_modules directory.");
  }
  return node_modules(path.join(root, ".."), count + 1);
}
node_modules.p = "";
function copy(options) {
  const copyStream = (filename, destname) => fs.createReadStream(filename).pipe(fs.createWriteStream(destname)).on("error", (error) => console.log(COLOURS.red(error.message)));
  return {
    name: "plugin-copy",
    configResolved(config) {
      (async () => {
        const { default: fastGlob } = await import("fast-glob");
        for (const option of options) {
          option.from = normalizePath(option.from);
          option.to = normalizePath(option.to);
          fastGlob(option.from, { cwd: config.root }).then((files) => {
            for (const filename of files) {
              let copyRoot;
              if (option.from.includes("*")) {
                const paths = option.from.split("/");
                copyRoot = paths.slice(0, paths.findIndex((p) => p.includes("*"))).join("/");
              } else {
                copyRoot = option.from;
              }
              option.to = path.isAbsolute(option.to) ? option.to : path.posix.join(config.root, option.to);
              const destname = path.posix.join(option.to, filename.replace(copyRoot, ""));
              ensureDir(destname);
              copyStream(filename, destname).on(
                "finish",
                () => console.log(COLOURS.green("[plugin/copy]"), destname.replace(config.root + "/", ""))
              );
            }
          });
        }
      })();
    }
  };
}
function debounce(fn, delay = 299) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), delay);
  };
}
function customStart(callback, debounceDelay = 300) {
  let config;
  if (callback) {
    callback = debounceDelay > 0 ? debounce(callback, debounceDelay) : callback;
  }
  return {
    name: "plugin-custom-start",
    configResolved(_config) {
      config = _config;
      const index = _config.plugins.findIndex((plugin) => plugin.name === ":startup");
      if (index > -1) {
        config.plugins.splice(index, 1);
      }
    },
    ondone({ filename }) {
      var _a;
      const { api: { vite }, experimental } = config;
      if (((_a = vite == null ? void 0 : vite.resolvedConfig) == null ? void 0 : _a.command) === "serve" && callback) {
        callback({
          startup: experimental.startup,
          reload: experimental.reload,
          filename
        });
      }
    }
  };
}
function dest(callback) {
  let config;
  let output;
  return {
    name: "plugin-dest",
    async configResolved(_config) {
      config = _config;
      output = _config.outDir;
      _config.output = void 0;
    },
    async ondone({ code, filename }) {
      const { experimental } = config;
      const destname = await (callback == null ? void 0 : callback(
        filename,
        experimental.input2output({ ...config, output }, filename)
      ));
      if (!destname)
        return;
      if (destname === filename) {
        const message = `Input and output are the same file
  ${filename} -> ${destname}`;
        throw new Error(message);
      }
      fs.writeFileSync(ensureDir(destname), code);
      console.log(COLOURS.green("[plugin/dest]"), new Date().toLocaleTimeString(), `${path.relative(config.root, destname)}`);
    }
  };
}
const CACHE_DIR = ".esmodule";
function esmodule(options) {
  return {
    name: "plugin-esmodule",
    async configResolved(config) {
      var _a;
      const { root } = config;
      let { include, cacheDir, buildOptions = {} } = options;
      cacheDir = normalizePath(path.resolve(root, cacheDir ?? CACHE_DIR));
      const aliasOptions = [];
      await Promise.all(include.map((name) => {
        aliasOptions.push({ find: new RegExp(`^${name}$`), replacement: [cacheDir, name].join("/") });
        const outfile = path.join(cacheDir, name + ".js");
        if (fs.existsSync(outfile)) {
          return;
        }
        return esmBundling({
          name,
          root,
          cacheDir,
          buildOptions
        });
      }));
      const aliasPlugin = alias(aliasOptions);
      (_a = aliasPlugin.configResolved) == null ? void 0 : _a.call(aliasPlugin, config);
      config.plugins.push(aliasPlugin);
    }
  };
}
async function esmBundling(args) {
  const {
    name,
    root,
    cacheDir,
    buildOptions = {}
  } = args;
  const cjs_require = node_module.createRequire(typeof document === "undefined" ? new (require("url")).URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("plugin/index.js", document.baseURI).href);
  buildOptions.format ?? (buildOptions.format = "cjs");
  buildOptions.target ?? (buildOptions.target = "node14");
  const pkgPath = path.join(node_modules(root), name);
  let entry;
  try {
    entry = cjs_require.resolve(pkgPath);
  } catch (error) {
    console.log(COLOURS.red(error));
    return;
  }
  const outfile = path.join(cacheDir, name + ".js");
  ensureDir(outfile);
  const result = await esbuild.build({
    entryPoints: [entry],
    outfile,
    target: "node14",
    format: "cjs",
    bundle: true,
    sourcemap: true,
    external: [
      ...node_module.builtinModules,
      ...node_module.builtinModules.map((mod) => `node:${mod}`)
    ],
    ...buildOptions
  });
  if (!result.errors.length) {
    console.log(COLOURS.green("[plugin/esmodule]"), path.posix.relative(root, outfile));
  }
  return result;
}
function loadViteEnv() {
  return {
    name: "plugin-load-vite-env",
    async configResolved(config) {
      const { api: { vite } } = config;
      let env = {};
      if (vite == null ? void 0 : vite.resolvedConfig) {
        env = vite.resolvedConfig.env ?? env;
      }
      const words = ["import", "meta", "env"];
      config.transformOptions.define = Object.fromEntries(Object.entries(env).map(([key, value]) => [words.concat(key).join("."), JSON.stringify(value)]));
    },
    transform({ code }) {
      const import_meta = "const import_meta = {}";
      const import_meta_polyfill = 'const import_meta = { url: "file:" + __filename, env: {/* Vite shims */} }';
      if (code.includes(import_meta)) {
        return code.replace(import_meta, import_meta_polyfill);
      }
    }
  };
}
exports.alias = alias;
exports.copy = copy;
exports.customStart = customStart;
exports.dest = dest;
exports.esmodule = esmodule;
exports.loadViteEnv = loadViteEnv;
